#单件模式
1. 经典回顾
2. 线程安全的Singleton
3. 细节决定成败
4. 细颗粒度Singleton
5. 自动更新的Singleton
6. 参数化的Singleton
7. 跨进程的Singleton
8. Singleton的扩展——Singleton-N
9. 引入配置文件管理Singleton
10. 基于类型参数的Generic Singleton
11. 由工厂类型协助Singleton实例管理
12. 小结

>Ensure a class only has one instance, and provide a global point of access to.

实现单件的方式有很多，但大体上可以划分为两种：
* 外部方式：客户程序在使用某些全局性对象时，做些“Try-Create-Store-Use”的工作，如果没有，就自己创建一个，但是仍把它搁在那个全局的位置上，如果原本有，就直接拿一个现成的。
* 内部方式：类型自己控制生成实例的数量，无论客户程序是否Try过了，类型自己就是一个实例，客户程序使用的都是这个现成的唯一实例。

相比较而言，外部方式实在不“靠谱”，毕竟应用中的类型不止一个，即便某个类型可以恪守这种先Try的方式，仍然可能有其他类型会用到它，很难要求所有相关类型都做这种唯一性检查，最终结果就是无法唯一。

>内部方式把干扰因素排除在类型之外，相对更保险一些。
>随着集群、多处理器和多核处理器的展开，想通过简单的类型内部控制，保持其真正的Singleton越来越难，确切来说，这个单件的“单”字是有上下文和语义范围限制的。


