经典工厂方法给我们设计应用一个很好的模式化 new()思维，通过引入新的对象，在很大程度上解放了客户程序对具体类型的依赖，
其方法就是延迟构造到子类执行，但依赖关系是始终存在的，解放一个对象的时候等于把麻烦转嫁到另一个对象上。
为此，工程中往往最后把推不掉的依赖关系推到配置文件上，也就是推到.NET Framework上，这样经典的工厂方法模式往往在项目中被演绎成“工厂方法 + 依赖注入 + 配置文件访问”的组合方式。

考虑到性能因素，或者干脆为了省去多次调用的麻烦，工程中往往会有生成一批对象的需要，比如生成具有某些配置选项的多个线程，这时候就会用到批量对象工厂。
写Demo和完成一个项目是两码事，其中一个关键的因素就是人，为了让整个实施过程中工厂的实现“中规中矩”，有时候要统一一些内容，泛型工厂能从根本上约束整个工厂体系的加工方法命名，也许它看起来要适应一段时间，但在使用上起码多了个选择。

最后就是工厂要为委托服务的问题，与经典工厂模式不同，委托自己就是抽象类型，工厂在创建的时候不是 new() 个类，关键是找到匹配的方法。

